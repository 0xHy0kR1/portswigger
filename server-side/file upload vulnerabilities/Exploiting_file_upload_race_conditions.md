## Introduction
- Modern frameworks generally don't upload files directly to their intended destination on the filesystem. Instead, they take precautions like uploading to a temporary, sandboxed directory first and randomizing the name to avoid overwriting existing files.
- They then perform validation on this temporary file and only transfer it to its destination once it is deemed safe to do so.
**Example** - 
some websites upload the file directly to the main filesystem and then remove it again if it doesn't pass validation. This kind of behavior is typical in websites that rely on anti-virus software and the like to check for malware
This may only take a few milliseconds, but for the short time that the file exists on the server, the attacker can potentially still execute it.
These vulnerabilities are often extremely subtle, making them difficult to detect during blackbox testing unless you can find a way to leak the relevant source code.

- Sometimes, when developers work on creating websites or applications, they need to handle files that users upload, like pictures or documents. To do this, they use frameworks or pre-made tools that help them manage these uploads safely.
	- However, some developers might choose to create their own way of handling file uploads without using these frameworks. Doing this can be quite complicated and challenging to get right.
	- The problem with this approach is that it can introduce a type of security issue called "race conditions."
	- A race condition is when different parts of the program try to access or modify the same data at the same time, and it becomes a "race" to see which part gets there first. This can lead to unpredictable and dangerous results.
	- **Example** - an attacker could exploit these race conditions to bypass even the strongest security checks put in place by the developer. In other words, they could sneak malicious files into the system, even if the developer had tried to protect against it.
	- In summary, creating your own file upload system without using established frameworks can be risky and complicated. It may lead to security vulnerabilities that malicious users can take advantage of, potentially bypassing any security measures you put in place. That's why it's generally safer to rely on well-tested frameworks for handling file uploads.

## Steps to solve lab
### Desc - Web shell upload via race condition
**Our end goal** - upload a basic PHP web shell, then use it to exfiltrate the contents of the file `/home/carlos/secret`. Submit this secret using the button provided in the lab banner.

1. Login with the credentials.
2. Upload an image to image upload function to check that function.
![[file-upload-vulnerabilities23.png]]

3. From the above concepts, we can predict that may be this website is depend on antivirus check for file validation and for this reason file stay in server for a couple of milliseconds and in that time we try to get the contents of that file and from this we perfectly bypass the security. Let's grab `POST /my-account/avatar` and `GET /files/avatars/shell.php` to send the file continuously and try make a `GET` request to the server.
![[file-upload-vulnerabilities24.png]]

4. Now, send these two request to the burp intruder and following settings as shown below:
**For POST** - 
![[file-upload-vulnerabilities26.png]]

select the payload type as `Null payloads` and payload setting to `Continue indefinitely`
![[file-upload-vulnerabilities25.png]]

**For GET** - 
![[file-upload-vulnerabilities27.png]]

select the payload type as `Null payloads` and payload setting to `Continue indefinitely`
![[file-upload-vulnerabilities28.png]]

5. Now, start the `GET` and `POST` at the same time to get the content of `secret` file of user `carlos`.
**For POST** - 
![[file-upload-vulnerabilities30.png]]

**For GET** - 
![[file-upload-vulnerabilities29.png]]

6. Now. this content and the lab is solved.

